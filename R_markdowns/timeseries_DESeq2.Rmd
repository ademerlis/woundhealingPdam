---
title: "wound_healing_analysis_manuscript_timeseries"
author: "allyson_demerlis"
date: "2022-10-25"
output: html_document
---
# Install and load necessary packages
```{r, install/load packages}
#if you need to install all the packages, you need the package "BiocManager" first.
# if (!require("BiocManager",quietly=TRUE))
#   install.packages("BiocManager")
#Now you can use BiocManager to install pacakges like DESeq2
#BiocManager::install("DESeq2")

library(DESeq2)

library(DEGreport) # needs BiocManager
  #DEGreport requires lasso2, which is not available for newer versions of R. To install lasso2, run library(remotes) (might need to install that package first), then run:
#install_version("lasso2", "1.2-22")

library(tidyverse) 
library(EnhancedVolcano) # needs BiocManager
library(ggpubr)
library(apeglm) # needs BiocManager
library(topGO) # needs BiocManager
library(GO.db) # needs BiocManager
library(Rgraphviz) # needs BiocManager
library(factoextra) #for PCA and eigenvectors
library(vegan) #for adonis function for PCA
library(VennDiagram)

library(scales) #for GO dot plot
library(viridis) #for GO dot plot
```


# Importing gene counts matrix and formatting it
```{r}
#reading in txt file as a table with the headers as the header in the original file
countsmatrix <-read.table("../input_files/WH_Pdam_original.Rmatrix.txt",header=TRUE)

#removing the Chromosome column from the dataset, and changing the rows to be the gene names
countsmatrix <-countsmatrix %>% 
  dplyr::select(-c("Chr", "Start", "End", "Strand", "Length")) %>% 
  column_to_rownames("Geneid")

#removing hour 5 from the dataset because it only has 1 wounded coral, so it is not comparable 
countsmatrix <- countsmatrix %>% 
  dplyr::select(!X5331C1:X5335Y)

#function found from stack overflow
#tidying column names so they don't include an X anymore (R puts an X in front of columns that start with numbers)
destroyX = function(es) {
  f = es
  for (col in c(1:ncol(f))){ #for each column in dataframe
    if (startsWith(colnames(f)[col], "X") == TRUE)  { #if starts with 'X' ..
      colnames(f)[col] <- substr(colnames(f)[col], 2, 100) #get rid of it
    }
  }
  assign(deparse(substitute(es)), f, inherits = TRUE) #assign corrected data to original name
}

destroyX(countsmatrix)
```


# Import gene feature annotation information
```{r}
genefeatures <- read.delim(file = "../input_files/pdam_genome_IDInfo.gff", header = F)
head(genefeatures)
colnames(genefeatures) <- c("IDGeneInfo")
rownames(genefeatures) <- rownames(countsmatrix)

#removing gene name from the second column
gene_name_split <- str_split_fixed(genefeatures$IDGeneInfo, " ", 2)
print(head(gene_name_split))
colnames(gene_name_split)<- c("Gene_ID","Gene_Function")
head(gene_name_split)
gene_name_split_df<-data.frame(gene_name_split)
head(gene_name_split_df)

#convert the Gene_ID column to the row headers
gene_name_split_df %>%
     remove_rownames() %>%
 column_to_rownames(var = 'Gene_ID')-> Pdam_Gene_Names_Info 
#%>%
  #write.csv(file="Pdam_Gene_Names_Info.csv")
```

# Trying LRT for time-series data
```{r}
metadata = data.frame(sample=colnames(countsmatrix),
                condition = stringr::str_detect(pattern = ".*C.*",string = colnames(countsmatrix)),
                hour = stringr::str_replace(pattern = "(.).*",replacement="\\1",string = colnames(countsmatrix)),
 id = stringr::str_replace(pattern=".(...).*",replacement="\\1",string=colnames(countsmatrix)))

#changing TRUE and FALSE for condition to Control and Wounded
metadata$condition[str_detect(metadata$condition,"TRUE")] <- "Control"
metadata$condition[str_detect(metadata$condition,"FALSE")] <- "Wounded"

metadata <- metadata %>% column_to_rownames("sample")

metadata$condition <- as.factor(metadata$condition)
```

```{r}
ddsLRT <- DESeqDataSetFromMatrix(countData = countsmatrix, colData = metadata, design = ~ condition + hour + condition:hour)
ddsLRT <- DESeq(ddsLRT, test="LRT", reduced = ~ condition)
resLRT <- results(ddsLRT)

resultsNames(ddsLRT)
```

# graph of normalized counts for a gene with condition-specific changes over time
```{r}
resLRT$symbol <- mcols(ddsLRT)$symbol
head(resLRT[order(resLRT$padj),], 4)

wounded_LRT <- plotCounts(ddsLRT, which.min(resLRT$padj), 
                   intgroup = c("hour","condition"), returnData = TRUE)

rownames(resLRT)[which.min(resLRT$padj)] #"pdam_00003271" is the gene with lowest p-value

wounded_LRT$hour <- as.numeric(as.character(wounded_LRT$hour))

ggplot(wounded_LRT,
  aes(x = hour, y = count, color = condition, group = condition)) + 
  geom_point() + stat_summary(fun.y=mean, geom="line") +
  scale_y_log10() + 
  theme_classic() +
  scale_color_manual(values = c("lightblue", "orange")) +
  labs(x="Hour", y="Normalized counts", title ="Gene pdam_00003271")
```

# Wald tests for log2fold changes at individual time points
```{r}
resultsNames(ddsLRT)
# list = "Intercept", "condition_Wounded_vs_Control", "hour_1_vs_0", "hour_2_vs_0", "hour_4_vs_0", "conditionWounded.hour1", "conditionWounded.hour2", "conditionWounded.hour4"   

res_wounded.hour1 <- results(ddsLRT, name = "conditionWounded.hour1", test="Wald")
res_wounded.hour1[which(res_wounded.hour1$padj < 0.05),] #only one gene is significant

res_wounded.hour2 <- results(ddsLRT, name = "conditionWounded.hour2", test="Wald")
res_wounded.hour2[which(res_wounded.hour2$padj < 0.05),] #only one gene is significant

res_wounded.hour4 <- results(ddsLRT, name = "conditionWounded.hour4", test="Wald")
res_wounded.hour4[which(res_wounded.hour4$padj < 0.05),] #only one gene is significant

res_woundedvscontrol <- results(ddsLRT, name = "condition_Wounded_vs_Control", test="Wald")
res_woundedvscontrol[which(res_woundedvscontrol$padj < 0.05),] # 2 genes overall: pdam_00008890 and pdam_00004156

#plot the 2 sig genes over time 

plotCounts(ddsLRT, gene = "pdam_00008890", 
                   intgroup = c("hour","condition"), returnData = TRUE) %>% 
mutate(hour = as.numeric(as.character(hour))) %>% 
  ggplot(.,
  aes(x = hour, y = count, color = condition, group = condition)) + 
  geom_point() + stat_summary(fun.y=mean, geom="line") +
  scale_y_log10() + 
  theme_classic() +
  scale_color_manual(values = c("lightblue", "orange")) +
  labs(x="Hour", y="Normalized counts", title ="Gene pdam_00008890")

plotCounts(ddsLRT, gene = "pdam_00004156", 
                   intgroup = c("hour","condition"), returnData = TRUE) %>% 
mutate(hour = as.numeric(as.character(hour))) %>% 
  ggplot(.,
  aes(x = hour, y = count, color = condition, group = condition)) + 
  geom_point() + stat_summary(fun.y=mean, geom="line") +
  scale_y_log10() + 
  theme_classic() +
  scale_color_manual(values = c("lightblue", "orange")) +
  labs(x="Hour", y="Normalized counts", title ="Gene pdam_00004156")
```

# use LFC to cluster significant genes by their profiles
```{r}
#first need to shrink LFC because this generates more accurate log2fold change estimates
#shrinkage means shrinking estimates towards zero

#ref: https://hbctraining.github.io/DGE_workshop/lessons/05_DGE_DESeq2_analysis2.html#:~:text=Shrunken%20log2%20foldchanges%20(LFC),High%20dispersion%20values

#lfcShrink works on one coefficient (comparison/contrast) at a time, so you need to run one for each coefficient from the LRT model

#(ref:http://master.bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html#time-course-experiments)

res_wounded.hour1_shrunk <- lfcShrink(ddsLRT, coef = "conditionWounded.hour1", type="apeglm")
plotMA(res_wounded.hour1_shrunk, ylim = c(-5, 5))

res_wounded.hour2_shrunk <- lfcShrink(ddsLRT, coef = "conditionWounded.hour2", type="apeglm")
plotMA(res_wounded.hour2_shrunk, ylim = c(-5, 5))

res_wounded.hour4_shrunk <- lfcShrink(ddsLRT, coef = "conditionWounded.hour4", type="apeglm")
plotMA(res_wounded.hour4_shrunk, ylim = c(-5, 5))

#compare to non-shrunken ones

plotMA(res_wounded.hour1, ylim = c(-5, 5))
plotMA(res_wounded.hour2, ylim = c(-5, 5))
plotMA(res_wounded.hour4, ylim = c(-5, 5))

```

# Principal component analyses and Scree plots
```{r}
#need to transform the data for plotting
dds_vst<- vst(ddsLRT,blind=FALSE)
plotPCA(dds_vst)
#plotPCA is one function to do it, or you can use the "prcomp" function, which lets you create a scree plot
pca_lrt <- prcomp(t(assay(dds_vst)))
fviz_eig(pca_lrt)
```

## PCA
```{r}
pca_LRT <- plotPCA(dds_vst,intgroup=c("condition","hour"),returnData = TRUE)
ggplot(pca_LRT, aes(PC1, PC2,shape=condition,color=hour)) + 
  geom_point(size=3) +  xlab(paste0("PC1 39% variance")) + 
  ylab(paste0("PC2 24% variance")) + 
  theme(legend.position="right")  + 
  theme(text = element_text(size=10))  + 
  theme(legend.key.size = unit(0.5, "cm")) + 
  geom_point(size = 3) +
  theme_classic() + 
  stat_ellipse(aes(PC1, PC2, group=hour), type = "norm")
```


# Volcano Plot for each hour
```{r}
# create custom key-value pairs for 'high', 'low', 'mid' expression by fold-change
  # this can be achieved with nested ifelse statements
 keyvals_h0 <- ifelse(
    res_h0$log2FoldChange < -2,'royalblue',
      ifelse(res_h0$log2FoldChange > 2, 'red',
        'black'))
  keyvals_h0[is.na(keyvals_h0)] <- 'black'
  names(keyvals_h0)[keyvals_h0 == 'red'] <- 'high'
  names(keyvals_h0)[keyvals_h0 == 'black'] <- 'mid'
  names(keyvals_h0)[keyvals_h0 == 'royalblue'] <- 'low'
  
keyvals_h1 <- ifelse(
    res_h1$log2FoldChange < -2, 'royalblue',
      ifelse(res_h1$log2FoldChange > 2, 'red',
        'black'))
  keyvals_h1[is.na(keyvals_h1)] <- 'black'
  names(keyvals_h1)[keyvals_h1 == 'red'] <- 'high'
  names(keyvals_h1)[keyvals_h1 == 'black'] <- 'mid'
  names(keyvals_h1)[keyvals_h1 == 'royalblue'] <- 'low'

keyvals_h2 <- ifelse(
    res_h2$log2FoldChange < -2, 'royalblue',
      ifelse(res_h2$log2FoldChange > 2, 'red',
        'black'))
  keyvals_h2[is.na(keyvals_h2)] <- 'black'
  names(keyvals_h2)[keyvals_h2 == 'red'] <- 'high'
  names(keyvals_h2)[keyvals_h2 == 'black'] <- 'mid'
  names(keyvals_h2)[keyvals_h2 == 'royalblue'] <- 'low'
  
keyvals_h4 <- ifelse(
    res_h4$log2FoldChange < -2, 'royalblue',
      ifelse(res_h4$log2FoldChange > 2, 'red',
        'black'))
  keyvals_h4[is.na(keyvals_h4)] <- 'black'
  names(keyvals_h4)[keyvals_h4 == 'red'] <- 'high'
  names(keyvals_h4)[keyvals_h4 == 'black'] <- 'mid'
  names(keyvals_h4)[keyvals_h4 == 'royalblue'] <- 'low'
  
#hour 0
EnhancedVolcano(res_h0, #The default cut-off for log2FC is >|2|; the default cut-off for P value is 10e-6.
    lab = rownames(res_h0),
    selectLab = rownames(res_h0)[which(names(keyvals_h0) %in% c('high', 'low'))],
    labSize = 4.5,
    colCustom = keyvals_h0,
    pCutoff = 10e-5,
    x = 'log2FoldChange',
    y = 'pvalue') #you want to use pvalue instead of padjusted for volcano visualization because padjusted turns all the non-significant ones to zero
ggsave("volcano_h0.pdf", width = 7, height = 10)

#hour 1
EnhancedVolcano(res_h1,
    lab = rownames(res_h1),
    selectLab = rownames(res_h1)[which(names(keyvals_h1) %in% c('high', 'low'))],
    labSize = 2,
    drawConnectors = TRUE,
    widthConnectors = 1.0,
    colCustom = keyvals_h1,
    pCutoff = 10e-5,
    x = 'log2FoldChange',
    y = 'pvalue')
ggsave("volcano_h1.pdf", width = 7, height = 10)

#hour 2
EnhancedVolcano(res_h2,
    lab = rownames(res_h2),
    selectLab = rownames(res_h2)[which(names(keyvals_h2) %in% c('high', 'low'))],
    labSize = 4.5,
    drawConnectors = TRUE,
    colCustom = keyvals_h2,
    pCutoff = 10e-5,
    x = 'log2FoldChange',
    y = 'pvalue')
ggsave("volcano_h2.pdf", width = 7, height = 10)
#note: one of the pdam genes (pdam_0009111) was annotated in EnhancedVolcano plot but isn't included in the anno_h2 dataset because we used the function "na.omit" to remove rows that had na's. However some of the significant genes have na's for the p-adjusted value.

#hour 4
EnhancedVolcano(res_h4,
    lab = rownames(res_h4),
    selectLab = rownames(res_h4)[which(names(keyvals_h4) %in% c('high', 'low'))],
    labSize = 4.5,
    pCutoff = 10e-5,
    colCustom = keyvals_h4,
    x = 'log2FoldChange',
    y = 'pvalue')
ggsave("volcano_h4.pdf", width = 7, height = 10)
```




# topGO analysis (Molecular Function)
```{r}
#following Michael Connelly's code (github)

#Input required *P. damicornis* GO annotation data and construct Gene-to-GO object for custom annotation mapping
GO_geneID<-readMappings(file="../2022 updates with Sami Beasley/pdam_genome_GOgenes.txt") #Mike made this file

geneID_GO <- inverseList(GO_geneID)
str(head(geneID_GO))

#Generate gene universe and GO universe from Gene-to-GO and GO-to-Gene objects
geneNames <- names(geneID_GO)
str(head(geneNames))

GONames <- names(GO_geneID)
str(head(GONames))
```

Hour 0 no annotations so no GO analysis

## topGO analysis Hour 1 Molecular Function (MF)
```{r}
#label differentially expressed genes as '1' and non-significant genes as '0'
res_h1_GO<-as.data.frame(res_h1)
res_h1_GO<- res_h1_GO%>%mutate(Group=case_when(padj<0.05~"1",padj>=0.05~"0"))
res_h1_GO<-na.omit(res_h1_GO)

#create the gene universe
gene_universe_h1<-as.numeric(res_h1_GO$Group)
gene_universe_h1<-factor(gene_universe_h1)
names(gene_universe_h1) <- rownames(res_h1_GO) 

#create topGO data object
GO_MF_h1 <-new("topGOdata",
                ontology="MF",
                allGenes=gene_universe_h1,
                nodeSize=10,
                annotationFun=annFUN.gene2GO,
                gene2GO = geneID_GO)

# tests to identify enriched gene ontology terms
GO_MF_h1_resultFisher01<-runTest(GO_MF_h1,algorithm = "weight01", statistic = "fisher")
GO_MF_h1_resultFisherclassic<-runTest(GO_MF_h1,algorithm = "classic", statistic = "fisher")
GO_MF_h1_resultclassicKS <- runTest(GO_MF_h1, algorithm = "classic", statistic = "ks")
GO_MF_h1_resultelimKS <- runTest(GO_MF_h1, algorithm = "elim", statistic = "ks")


#generate results table
GO_MF_h1_resultstable<-GenTable(GO_MF_h1, 
                                Fisher01 = GO_MF_h1_resultFisher01,
                                Fisherclassic = GO_MF_h1_resultFisherclassic,
                                classicKS = GO_MF_h1_resultclassicKS,
                                elimKS = GO_MF_h1_resultelimKS,
                                topNodes = 50)

showSigOfNodes(GO_MF_h1,score(GO_MF_h1_resultelimKS),firstSigNodes = 5,useInfo = 'all')

GO_MF_h1_resultstable %>% filter(Significant >= 1) %>% mutate(hour=1)-> sigGO_MF_h1 #filter for genes from this time point that are significantly associated with the GO terms (which are also significantly enriched)
```


## topGO analysis Hour 2 Molecular Function (MF)
```{r}
#label differentially expressed genes as '1' and non-significant genes as '0'
res_h2_GO<-as.data.frame(res_h2)
res_h2_GO<- res_h2_GO%>%mutate(Group=case_when(padj<0.05~"1",padj>=0.05~"0"))
res_h2_GO<-na.omit(res_h2_GO)

#create the gene universe
gene_universe_h2<-as.numeric(res_h2_GO$Group)
gene_universe_h2<-factor(gene_universe_h2)
names(gene_universe_h2) <- rownames(res_h2_GO) 

#create topGO data object
GO_MF_h2 <-new("topGOdata",
                ontology="MF",
                allGenes=gene_universe_h2,
                nodeSize=10,
                annotationFun=annFUN.gene2GO,
                gene2GO = geneID_GO)

# tests to identify enriched gene ontology terms
GO_MF_h2_resultFisher01<-runTest(GO_MF_h2,algorithm = "weight01", statistic = "fisher")
GO_MF_h2_resultFisherclassic<-runTest(GO_MF_h2,algorithm = "classic", statistic = "fisher")
GO_MF_h2_resultclassicKS <- runTest(GO_MF_h2, algorithm = "classic", statistic = "ks")
GO_MF_h2_resultelimKS <- runTest(GO_MF_h2, algorithm = "elim", statistic = "ks")


#generate results table
GO_MF_h2_resultstable<-GenTable(GO_MF_h2, 
                                Fisher01 = GO_MF_h2_resultFisher01,
                                Fisherclassic = GO_MF_h2_resultFisherclassic,
                                classicKS = GO_MF_h2_resultclassicKS,
                                elimKS = GO_MF_h2_resultelimKS,
                                topNodes = 50)

showSigOfNodes(GO_MF_h2,score(GO_MF_h2_resultelimKS),firstSigNodes = 5,useInfo = 'all')

GO_MF_h2_resultstable %>% filter(Significant >= 1) %>% mutate(hour=2)-> sigGO_MF_h2 #filter for genes from this time point that are significantly associated with the GO terms (which are also significantly enriched)
```

## topGO analysis Hour 4 Molecular Function (MF)
```{r}
#label differentially expressed genes as '1' and non-significant genes as '0'
res_h4_GO<-as.data.frame(res_h4)
res_h4_GO<- res_h4_GO%>%mutate(Group=case_when(padj<0.05~"1",padj>=0.05~"0"))
res_h4_GO<-na.omit(res_h4_GO)

#create the gene universe
gene_universe_h4<-as.numeric(res_h4_GO$Group)
gene_universe_h4<-factor(gene_universe_h4)
names(gene_universe_h4) <- rownames(res_h4_GO) 

#create topGO data object
GO_MF_h4 <-new("topGOdata",
                ontology="MF",
                allGenes=gene_universe_h4,
                nodeSize=10,
                annotationFun=annFUN.gene2GO,
                gene2GO = geneID_GO)

# tests to identify enriched gene ontology terms
GO_MF_h4_resultFisher01<-runTest(GO_MF_h4,algorithm = "weight01", statistic = "fisher")
GO_MF_h4_resultFisherclassic<-runTest(GO_MF_h4,algorithm = "classic", statistic = "fisher")
GO_MF_h4_resultclassicKS <- runTest(GO_MF_h4, algorithm = "classic", statistic = "ks")
GO_MF_h4_resultelimKS <- runTest(GO_MF_h4, algorithm = "elim", statistic = "ks")


#generate results table
GO_MF_h4_resultstable<-GenTable(GO_MF_h4, 
                                Fisher01 = GO_MF_h4_resultFisher01,
                                Fisherclassic = GO_MF_h4_resultFisherclassic,
                                classicKS = GO_MF_h4_resultclassicKS,
                                elimKS = GO_MF_h4_resultelimKS,
                                topNodes = 50)

showSigOfNodes(GO_MF_h4,score(GO_MF_h4_resultelimKS),firstSigNodes = 5,useInfo = 'all')

GO_MF_h4_resultstable %>% filter(Significant >= 1) %>% mutate(hour=4)-> sigGO_MF_h4 #filter for genes from this time point that are significantly associated with the GO terms (which are also significantly enriched)
```


## combine all significant gene GO lists per hour and visualize as table
```{r}
full_join(sigGO_MF_h1, sigGO_MF_h2) %>% full_join(., sigGO_MF_h4) %>%  #144 GO terms total
  filter(Fisherclassic < 0.05) #25 GO terms now
  #write_csv("GO_MF_allhours.csv")

#dot plot
full_join(sigGO_MF_h1, sigGO_MF_h2) %>% full_join(., sigGO_MF_h4) %>%
  filter(Fisherclassic < 0.05) %>% 
  mutate(Fisherclassic = as.numeric(Fisherclassic)) %>% 
  mutate(Annotated = as.numeric(Annotated)) %>% 
ggplot(data=., aes(x=-log(Fisherclassic), y=reorder(Term, -Fisherclassic))) +
    geom_point(aes(size=Annotated, color=-log(Fisherclassic))) +
    scale_color_viridis(option="plasma") +
  labs(x="-log P-Value", y="Gene Ontology Term Description", title=paste("Significant Molecular Functions"), color = "-log(P-value)") +
  scale_y_discrete(labels = function(x) str_wrap(x, width = 30)) +
  theme_bw() +
  facet_grid(vars(hour), scales = "free") + 
  scale_size(range = c(2,6))
##ggsave("significantMF_GO_perhour.pdf")

#need to make one that has the GO term next to it so I can easily google it for the illustrator manual edits
full_join(sigGO_MF_h1, sigGO_MF_h2) %>% full_join(., sigGO_MF_h4) %>%
  filter(Fisherclassic < 0.05) %>% 
  mutate(Fisherclassic = as.numeric(Fisherclassic)) %>% 
  mutate(Annotated = as.numeric(Annotated)) %>% 
  mutate(GO_term=str_c(GO.ID,Term, sep=" ")) %>% 
  ggplot(data=., aes(x=-log(Fisherclassic), y=reorder(GO_term, -Fisherclassic))) +
    geom_point(aes(size=Annotated, color=-log(Fisherclassic))) +
    scale_color_viridis(option="plasma") +
  labs(x="-log P-Value", y="Gene Ontology Term Description", title=paste("Significant Molecular Functions"), color = "-log(P-value)") +
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50)) +
  theme_bw() +
  facet_grid(vars(hour), scales = "free") + 
  scale_size(range = c(2,6))
```



# Venn Diagrams
## for DGEs at each hour
```{r}
# need to manually calculate the totals and the intersects of each interaction (0-1, 0-2, 0-4, 1-2, 1-4, 2-4)

# use data frames anno_h0, anno_h1, anno_h2, anno_h4
# all DEGs is annotated_DEG_list

length(annotated_DEG_list$Row.names) #142 total

##Pairwise
h0_h1 <- intersect(anno_h0$Row.names, anno_h1$Row.names)
h0_h2 <- intersect(anno_h0$Row.names, anno_h2$Row.names)
h0_h4 <- intersect(anno_h0$Row.names, anno_h4$Row.names)
h1_h2 <- intersect(anno_h1$Row.names, anno_h2$Row.names)
h1_h4 <- intersect(anno_h1$Row.names, anno_h4$Row.names)
h2_h4 <- intersect(anno_h2$Row.names, anno_h4$Row.names)

##Triple
h0_h1_h2 <- intersect(h0_h1, anno_h2$Row.names)
h0_h2_h4 <- intersect(h0_h2, anno_h4$Row.names)
h1_h2_h4 <- intersect(h1_h2, anno_h4$Row.names)
h0_h1_h4 <- intersect(h0_h1, anno_h4$Row.names)
##Quadruple
h0_h1_h2_h4 <- intersect(h0_h1, h2_h4)

DGE_hour_venn <- draw.quad.venn(area1 = length(anno_h0$Row.names),
               area2 = length(anno_h1$Row.names),
               area3 = length(anno_h2$Row.names),
               area4 = length(anno_h4$Row.names),
               n12 = length(h0_h1),
               n13 = length(h0_h2),
               n14 = length(h0_h4),
               n23 = length(h1_h2),
               n24 = length(h1_h4),
               n34 = length(h2_h4),
               n123 = length(h0_h1_h2),
               n124 = length(h0_h1_h4),
               n134 = length(h0_h2_h4),
               n234 = length(h1_h2_h4),
               n1234 = length(h0_h1_h2_h4),
               category = c("Hour 0", "Hour 1", "Hour 2", "Hour 4"),
               fill = c("olivedrab3", "skyblue", "springgreen", "deepskyblue"),
               lwd = rep(1,4),
               cat.cex = rep(1.4, 4),
               #cat.fontfamily = rep("Arial", 4),
               cat.fontface = rep("plain", 4),
               alpha = c(0.3,0.3,0.3,0.3),
               cex = c(rep(1.4,5), 3, rep(1.4, 9)),
               fontface = c(rep("plain", 5), "bold", rep("plain", 9)),
               #fontfamily = c(rep("Arial", 15)),
               label.col = c(rep("black", 5), "red", rep("black", 9)),
               print.mode = "raw",
               sigdigs = 2,
               scaled = TRUE
) 
#pdf("~/OneDrive - University of Miami/Cnidimmunity Lab/Wound_Healing_Project/2022 updates with Sami Beasley/manuscript figures and tables/VennDiagram_DGEallhours")
grid.draw(DGE_hour_venn)
```





